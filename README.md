# tapas-fs22
The master repository for the TAPAS application to be developed in Fall Semester 2022.

## Project Structure
This project is structured as follows:
* [tapas-tasks](tapas-tasks): standalone project for the Tapas-Tasks micro-service (Spring Boot project)
    * [tapas-tasks/README.md](tapas-tasks/README.md): README file for the Tapas Tasks service with more details. 
    * [tapas-tasks/src](tapas-tasks/src): source code of the project (following the Hexagonal Architecture)
    * [tapas-tasks/pom.xml](tapas-tasks/pom.xml): Maven pom-file
* [app](app): 
  * a very simple web service developed using Spring Boot, based on the tutorial at https://spring.io/guides/gs/spring-boot/
  * extended with the [NewTaskController](app/src/main/java/ch/unisg/app/NewTaskController.java) showing an example of using a circuit breaker based on Hystrix
* [docker-compose.yml](docker-compose.yml): Docker Compose configuration file for all services
* [docker-compose-local.yml](docker-compose-local.yml): Docker Compose configuration file to run all services on local Docker
* [docker-compose-local-mongo.yml](docker-compose-local-mongo.yml): Docker Compose configuration file to only run MongoDB on local Docker
* [.github/workflows/build-and-deploy.yml](.github/workflows/build-and-deploy.yml): GitHub actions script (CI/CD workflow)

## How to Add a New Service with Spring Boot

### Create a new Spring Boot project

* Recommended: use [Spring Initialzr](https://start.spring.io/) (Maven, Spring Boot 2.7.4, Jar, Java 17, dependencies as needed)
* Set the Spring application properties for your service (e.g., port of the web server) in `src/resources/application.properties`

### Update the Docker Compose file
Your TAPAS application is a multi-container Docker application ran with [Docker Compose](https://docs.docker.com/compose/).
To add your newly created service to the Docker Compose configuration file, you need to create a new service
definition in [docker-compose.yml](docker-compose.yml):
* copy and edit the `tapas-tasks` service definition from [lines 44-57](docker-compose.yml)
* change `command` (see [line 46](docker-compose.yml)
  to use the name of the JAR file generated by Maven for your service
    * note: if you change the version of your service, you need to update this line to reflect the change
* update the Traefik label names to reflect the name of your new service (see [line 52](docker-compose.yml))
    * e.g., change `traefik.http.routers.tapas-tasks.rule` to `traefik.http.routers.<new-service-name>.rule`
* update the Traefik `rule` (see [line 53](docker-compose.yml)) with the name of your new service: ``Host(`<new-service-name>.${PUB_IP}.asse.scs.unisg.ch`)``
* update the Traefik `port` (see [line 54](docker-compose.yml)) with the port configured for your new service

### Update the local Docker Compose file
In the [local docker compose file](docker-compose-local.yml) you need to copy and adjust lines 18-28.

### Update the GitHub Actions Workflow
This project uses GitHub Actions to build and deploy your TAPAS application whenever a new commit is
pushed on the `main` branch. You can add your new service to the GitHub Actions workflow defined in
[.github/workflows/build-and-deploy.yml](.github/workflows/build-and-deploy.yml):
* copy and edit the definition for `tapas-tasks` from [line 27-29](.github/workflows/build-and-deploy.yml)
* update the `mvn` command used to build your service to point to the `pom.xml` file of your new service (see [line 28](.github/workflows/build-and-deploy.yml))
* update the `cp` command to point to the JAR file of your new service directive (see [line 29](.github/workflows/build-and-deploy.yml))
    * note you will need to update the complete file path (folder structure and JAR name)

### How to Run the TAPAS Tasks Service Locally
You can run your micro-services on your local machine just like a regular Maven project:
* Run from IntelliJ:
    * Reload *pom.xml* if necessary
    * Run the micro-service's main class from IntelliJ for all required projects
    * Adapt the run configuration for the main file to include the VM argument:
  ```-Dspring.profiles.active=local``` to let Spring Boot use the application-local.properties file (if available).
* Use Maven to run from the command line:
```shell
mvn spring-boot:run -D"Spring-boot.run.profiles=local"
```
* Run with local Docker:
```shell
docker compose -f docker-compose-local.yml up --build
```

## How to Deploy on your VM
1. Start your Ubuntu VM on Switch.
    * VM shuts down automatically at 2 AM
    * Group admins can do this via https://engines.switch.ch/horizon
2. Push new code to the *main* branch
    * Check the status of the workflow on the *Actions* page of the GitHub project
    * We recommend to test your project locally before pushing the code to GitHub.
3. Open in your browser `https://app.${PUB_IP}.asse.scs.unisg.ch`

For the server IP address (see below), you should use dashes instead of dots, e.g.: `127.0.0.1` becomes `127-0-0-1`.

## VM Configurations

Specs (we can upgrade if needed):
* 1 CPU
* 2 GB RAM
* 20 GB HD
* Ubuntu 22.04

| Name | Server IP |
|-------|-----------|
|SCS-ASSE-VM-Group1|86.119.35.40|
|SCS-ASSE-VM-Group2|86.119.35.213|
|SCS-ASSE-VM-Group3|86.119.34.242|
|SCS-ASSE-VM-Group4|86.119.35.199|
|SCS-ASSE-VM-Group5|86.119.35.72|

## Architecture Decision Records
We recommend to use [adr-tools](https://github.com/npryce/adr-tools) to manage your ADRs here in
this GitHub project in a dedicated folder. The tool works best on a Mac OS or Linux machine.
